pragma solidity ^0.4.15;

contract grantList {
  struct companyRecord {
      //A access B's data : fromCompany is A, toCompany is B.
      string toCompany; //target company
      string fromCompany; //source company
      string accessCode;  //random code generated by A
      string fromCompanyPubKey; //A's public key of tessera
      string signedCode; //B generated (B sign this accessCode)
      address creator; // creator's address(A's public key of ehtereum);
      address contractAddress;
  }

  address public owner;
  uint public mapSize;
  mapping (uint=>companyRecord) public mapAccess;  // A's address(toCompany's address);
  mapping (uint=>address) public mapIndex;

  constructor () public {
     owner = msg.sender;
     mapSize = 0;
  }

  function insertRecord(string toCompany, string fromCompany, string accessCode,
      string fromCompanyPubKey, string signedCode) public  returns(address) {

    mapAccess[mapSize].toCompany = toCompany;
    mapAccess[mapSize].fromCompany = fromCompany;
    mapAccess[mapSize].accessCode = accessCode;
    mapAccess[mapSize].fromCompanyPubKey = fromCompanyPubKey;
    mapAccess[mapSize].signedCode = signedCode;
    mapAccess[mapSize].creator = msg.sender;
    //mapAccess[mapSize].contractAddress = "";

    mapIndex[mapSize] = msg.sender; //two map index
    mapSize++;
    return owner;
  }
  
  function updateRecord(uint index, string signedCode) public  returns(bool) {
    mapAccess[index].signedCode = signedCode;
    return true;
  }
  
  function findIndex(uint startIndex, address creator) public constant returns(uint ) {
      for(; startIndex < mapSize; startIndex++) {
          if (mapIndex[startIndex] == creator){
              return startIndex;
          }
      }
  }
}
